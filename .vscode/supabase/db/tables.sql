

create table public.roles (
  id smallint generated by default as identity not null,
  "user" uuid not null,
  constraint roles_pkey primary key (id),
  constraint roles_user_key unique ("user"),
  constraint roles_user_fkey foreign KEY ("user") references auth.users (id) on update CASCADE on delete RESTRICT
) TABLESPACE pg_default;




create table public.profile (
  id uuid not null default gen_random_uuid (),
  lang public.lang not null default 'en'::public.lang,
  theme public.theme not null default 'light'::public.theme,
  is_active boolean null default true,
  constraint profile_pkey primary key (id),
  constraint profile_id_fkey foreign KEY (id) references auth.users (id) on update CASCADE on delete RESTRICT
) TABLESPACE pg_default;

create table publiclogin_attempts (
  id uuid default gen_random_uuid() primary key,
  user_id uuid,
  email text,
  attempt_time timestamp with time zone default now(),
  reason text
);


CREATE POLICY "Solo usuarios activos pueden leer datos"
ON profiles FOR SELECT
USING (is_active = true);


CREATE POLICY "Permitir inserci√≥n de intentos de login"
ON public.login_attempts FOR INSERT
WITH CHECK (true);

-- Permitir a administradores ver todos los intentos
CREATE POLICY "Permitir lectura a administradores"
ON public.login_attempts FOR SELECT
USING (auth.uid() IN (SELECT user_id FROM admin_users));


create or replace function get_login_attempts_with_user_email()
returns table(
  user_email varchar,
  reason text,
  created_at timestamp
)
language plpgsql
security definer
as $$
begin
  return query
  select
    auth.users.email,
    public.login_attempts.reason,
    public.login_attempts.created_at
  from
    public.login_attempts
  join
    auth.users on public.login_attempts.user = auth.users.id
  order by
    public.login_attempts.created_at desc;
end;
$$;